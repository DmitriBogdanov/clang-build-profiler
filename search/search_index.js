var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Overview","text":""},{"location":"index.html#clang-build-profiler","title":"clang-build-profiler","text":"<p>clang-build-profiler is a CLI tool that analyzes timings generated by <code>clang++ -ftime-trace</code> and generates a human-readable report, summarizing which parts of the build took the longest.</p>"},{"location":"index.html#quick-showcase","title":"Quick showcase","text":"<ol> <li> <p>Build your project using <code>clang++</code> with <code>-ftime-trace</code> flag enabled</p> </li> <li> <p>Point the CLI tool at the CMake build directory and select its desired output:</p> </li> </ol> <p></p> <ol> <li>Open the generated report:</li> </ol> <p> </p> <ol> <li>Available output formats include:</li> </ol> <code>--output</code> Description Requirements <code>mkdocs</code> Nicest output for viewing, it uses MkDocs Material to serve an interactive GUI in browser <code>pip install mkdocs-material</code> <code>html</code> Stand-alone HTML report, not as fancy, but doesn't require MkDocs None <code>terminal</code> Colored in-terminal output, useful for small projects or with high level of pruning None <code>json</code> JSON dump of profiling data, useful for custom analysis pipelines None <code>text</code> Text file output, useful for saving human-readable build artifacts with profiling data None"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Builds a tree of includes and their parse timings</li> <li>Builds a tree of template instantiations and their timings</li> <li>Summarizes the information above into a digestible format</li> <li>Prettifies standard templates and their expansion (e.g. <code>std::basic_string&lt;char, ...&gt;</code> \u279c <code>std::string</code>)</li> <li>Automatically analyzes CMake builds with multiple targets</li> </ul>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The project website serves as its main form of documentation.</p> <p>The docs can also be viewed directly from GitHub:</p> <ul> <li>Getting started</li> <li>Configuration file</li> <li>Supported CLI flags</li> <li>Building the project locally</li> <li>Technical limitations</li> </ul> <p>A shorter built-in documentation can be accessed with <code>clang-build-profiler --help</code>.</p>"},{"location":"index.html#motivation","title":"Motivation","text":"<p>In many cases, build times can be noticeably improved through a relatively minor reorganization. To make this feasible, however, one would need a proper tool capable of profiling the build process.</p> <p><code>clang++ -ftime-trace</code> introduced in version <code>9.0</code> provides a perfect backend for such a tool, it generates traces in the Chrome tracing format, which can be even opened directly using Chrome <code>about:tracing</code>. However, raw traces are quite cumbersome to analyze in respect to the things that we actually care about, so I implemented a tool to summarize the key information.</p>"},{"location":"index.html#dependencies","title":"Dependencies","text":"<p>The source code of this project embeds several dependencies:</p> Library Version License Used for UTL v8.3.3 MIT Formatting fmt v12.1.0 MIT Formatting &amp; terminal IO glaze v6.0.0 MIT JSON parsing &amp; serialization argparse v3.2 MIT CLI argument parsing fkYAML v0.4.2 MIT YAML parsing Boost.Regex v7.0.1 Boost Regular expressions cmrc #952ffdd MIT Embedding resources"},{"location":"index.html#roadmap","title":"Roadmap","text":"<ul> <li>Possibly a native GUI output with <code>--output=gui</code></li> <li>Refinements in template prettification</li> <li>Tests on larger codebases</li> <li>A better selection of summaries</li> <li>Performance improvements</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE.md for details.</p>"},{"location":"LICENSE.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Dmitri Bogdanov</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"building_locally.html","title":"Building the project locally","text":"<p>&lt;- to README.md</p>"},{"location":"building_locally.html#building-the-project","title":"Building the project","text":""},{"location":"building_locally.html#prerequisites","title":"Prerequisites","text":"<p>This project uses CMake with presets as a main way of managing platform-dependent configuration.</p> <p>Since using the tool in question inherently requires an installation of <code>clang++</code>, it is usually built with same compiler using <code>clang</code> preset. Other toolchains are also supported through <code>msvc</code> and <code>gcc</code> presets.</p> <p>On most systems LLVM provides both system packages and an automatic install script:</p> <pre><code>wget https://apt.llvm.org/llvm.sh &amp;&amp;\nchmod +x llvm.sh                  &amp;&amp;\nsudo ./llvm.sh all\n</code></pre> <p>For Windows, both <code>cmake</code> and <code>clang++</code> toolchain can be set up through Visual Studio Installer.</p>"},{"location":"building_locally.html#building","title":"Building","text":"<p>Clone the repo:</p> <pre><code>git clone https://github.com/DmitriBogdanov/clang-build-profiler.git &amp;&amp;\ncd \"clang-build-profiler/\"\n</code></pre> <p>Configure CMake:</p> <pre><code>cmake --preset=clang\n</code></pre> <p>Build the project:</p> <pre><code>cmake --build --preset=clang\n</code></pre> <p>The binary can be found at <code>build/clang-build-profiler</code>.</p>"},{"location":"building_locally.html#building-the-docs","title":"Building the docs","text":""},{"location":"building_locally.html#prerequisites_1","title":"Prerequisites","text":"<p>This repo uses MkDocs with Material theme to build the website version of documentation.</p> <p><code>python3</code> can be downloaded from the official website or using a package manager:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install python3\n</code></pre> <p>After this, to install necessary dependencies run:</p> <pre><code>pip install mkdocs-material mkdocs-material[imaging] markdown-callouts\n</code></pre>"},{"location":"building_locally.html#building_1","title":"Building","text":"<p>To build the documentation locally and view it immediately run:</p> <pre><code>mkdocs serve --open\n</code></pre> <p>To build a version for distribution run:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"cli_arguments.html","title":"Supported CLI arguments","text":"<p>&lt;- to README.md</p> Argument Type Default value Description <code>-h</code>, <code>--help</code> Unique flag - Displays help message <code>-v</code>, <code>--version</code> Unique flag - Displays application version <code>-w</code>, <code>--write-config</code> Unique flag - Creates config file corresponding to the default configuration <code>-c</code>, <code>--config</code> Optional argument <code>.clang-build-profiler</code> Specifies custom config path <code>-a</code>, <code>--artifacts</code> Optional argument <code>.cbp/</code> Specifies custom output directory <code>-o</code>, <code>--output</code> Optional argument <code>terminal</code> Selects profiling output format <code>-b</code>, <code>--build</code> Exclusive group [1] <code>build/</code> Selects CMake build directory <code>-t</code>, <code>--target</code> Exclusive group [1] - Selects build artifacts directory <code>-f</code>, <code>--file</code> Exclusive group [1] - Selects specific translation unit"},{"location":"cli_arguments.html#examples","title":"Examples","text":""},{"location":"cli_arguments.html#view-help","title":"View help","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --help\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -h\n</code></pre>"},{"location":"cli_arguments.html#view-version","title":"View version","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --version\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -v\n</code></pre>"},{"location":"cli_arguments.html#write-default-config","title":"Write default config","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --write-config\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -w\n</code></pre>"},{"location":"cli_arguments.html#specify-custom-config-path","title":"Specify custom config path","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --config=\"configs/clang-build-profiler.yml\"\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -c \"configs/clang-build-profiler.yml\"\n</code></pre>"},{"location":"cli_arguments.html#specify-custom-output-path","title":"Specify custom output path","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --artifacts=\"data/clang-build-profiler/\"\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -a \"data/clang-build-profiler/\"\n</code></pre>"},{"location":"cli_arguments.html#specify-output-format","title":"Specify output format","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --output=json\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -o json\n</code></pre>"},{"location":"cli_arguments.html#specify-trace-file","title":"Specify trace file","text":"<p>Verbose form:</p> <pre><code>clang-build-profiler --file=\"build/main.cpp.json\"\n</code></pre> <p>Short form:</p> <pre><code>clang-build-profiler -f \"build/main.cpp.json\"\n</code></pre>"},{"location":"configuration_file.html","title":"Configuration file","text":"<p>&lt;- to README.md</p>"},{"location":"configuration_file.html#basics","title":"Basics","text":"<p>Following the convention of other LLVM tools, <code>clang-build-profiler</code> uses a YAML config <code>.clang-build-profiler</code> placed into the project root.</p> <p>This means, for a project using other things from the LLVM toolchain, the root directory might look something like this:</p> <pre><code>docs/\ninclude/\nsource/\n.clang-build-profiler\n.clang-format\n.clang-tidy\n.clangd\n.gitignore\n</code></pre> <p>The config contains project-specific settings such as coloring, name simplification rules and etc.</p>"},{"location":"configuration_file.html#schema","title":"Schema","text":"<p>Below in a default config used by the program:</p> clang-build-profiler<pre><code>version: \"0.1.0\"\n\n# The main profiling output\ntree:\n\n  # Node color &amp; pruning thresholds, for example:\n  #   'gray  :  90' =&gt; color durations &gt;  90 ms gray\n  #   'white : 150' =&gt; color durations &gt; 150 ms white\n  #   'yellow: 300' =&gt; color durations &gt; 300 ms yellow\n  #   'red   : 800' =&gt; color durations &gt; 800 ms red\n  #   Nodes without a color are hidden, to disable all pruning set 'gray' to '0'\n  categorize:\n    gray  :  90\n    white : 150\n    yellow: 300\n    red   : 800\n\n  # Automatically detect &amp; simplify standard header includes, for example:\n  #   'false' =&gt; '/usr/lib/llvm-21/include/c++/v1/filesystem'\n  #   'true'  =&gt; '&lt;filesystem&gt;'\n  detect_standard_headers: true\n\n  # Automatically detect &amp; simplify project header includes, for example:\n  #   'false' =&gt; '/home/.../clang-build-profiler/include/utility/replace.hpp'\n  #   'true'  =&gt; 'include/utility/replace.hpp'\n  detect_project_headers:  true\n\n  # Create alias for some filepaths, for example:\n  #   '- from: \"include/external/boost/\"' =&gt; includes paths beginning with \"include/external/boost/\"\n  #   '  to  : \"boost/\"                 '    will be shortened to \"boost/\"\n  replace_filepath:\n    - from: \"include/\"\n      to  : \"\"\n    - from: \"source/\"\n      to  : \"\"\n</code></pre> <p>To serialize this config for modification we can run:</p> <pre><code>clang-build-profiler --write-config\n</code></pre> <p>Which will write a copy of default <code>.clang-build-profiler</code> unless one is already present.</p> <p>Tip</p> <p>Setting <code>tree.categorize.gray</code> to <code>0</code> will disable all pruning, showing the full tree of includes and template instantiations. In most cases this amount of information is excessive and will produce multiple MBs of raw data, values above <code>30</code> are a reasonable default to ignore.</p>"},{"location":"getting_started.html","title":"Getting started","text":"<p>&lt;- to README.md</p>"},{"location":"getting_started.html#installation","title":"Installation","text":"<p>Pre-compiled binaries can be found in Releases for following platforms:</p> <ul> <li>Windows x86-64</li> <li>Ubuntu x86-64</li> <li>MacOS x86-64</li> </ul> <p>For platforms outside of the supported list, the build can be produced locally, see the corresponding guide.</p> <p>In all cases, <code>clang-build-compiler</code> is a stand-alone executable with no additional dependencies.</p> <p>For additional convenience it is advised to add <code>clang-build-compiler</code> to the <code>PATH</code>.</p>"},{"location":"getting_started.html#usage","title":"Usage","text":""},{"location":"getting_started.html#basics","title":"Basics","text":"<p>Compile your project using <code>clang++</code> with <code>-ftime-trace</code> flag enabled. The compiler will place JSON traces together with the object files.</p> <p>To analyze a specific trace (which corresponds to a single translation unit) and output results to the terminal run:</p> <pre><code>clang-build-profiler --file=&lt;path_to_json_trace&gt;\n</code></pre> <p>To analyze all traces in a directory run:</p> <pre><code>clang-build-profiler --target=&lt;path_to_directory&gt;\n</code></pre> <p>To analyze an entire CMake build run:</p> <pre><code>clang-build-profiler --build=&lt;path_to_cmake_build&gt;\n</code></pre> <p>Tip</p> <p>When invoked with no arguments, <code>clang-build-profiler</code> assumes <code>--build=build/</code> by default.</p> <p>Output example:</p> <p></p> <p>Using <code>--output=html</code> we can generate a stand-alone HTML report with collapsable sections:</p> <p></p> <p>Generated report can be opened in any browser:</p> <p></p>"},{"location":"getting_started.html#making-the-output-pretty","title":"Making the output pretty","text":"<p>Using <code>mkdocs</code> we can generate even prettier reports with proper GUI.</p> <p><code>mkdocs</code> can be installed with <code>pip</code>:</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>After this we can analyze the build:</p> <pre><code>clang-build-profiler --output=mkdocs\n</code></pre> <p>And visualize it in the browser using <code>mkdocs</code>:</p> <pre><code>(cd .cbp &amp;&amp; mkdocs serve --open)\n</code></pre> <p>Output example:</p> <p> </p> <p>Tip</p> <p><code>pip</code> together with <code>python3</code> can be installed using <code>apt</code> or grabbed directly from the official website:</p> <pre><code>sudo apt update &amp;&amp;\nsudo apt install python3\n</code></pre>"},{"location":"getting_started.html#configuration-file","title":"Configuration file","text":"<p>Following the convention of other LLVM tools, <code>clang-build-profiler</code> uses a YAML config <code>.clang-build-profiler</code> placed into the project root.</p> <p>This config contains project-specific settings such as coloring, name simplification rules and etc.</p> <p>For more details, see the corresponding guide</p>"},{"location":"technical_limitations.html","title":"Technical limitations","text":"<p>&lt;- to README.md</p>"},{"location":"technical_limitations.html#transitive-include-attribution","title":"Transitive include attribution","text":"<p>It is possible that multiple headers <code>h1.hpp</code> and <code>h2.hpp</code> transitively include the same header <code>heavy.hpp</code>.</p> <p>Since include guards prevent headers from being parsed twice, profiling results will attribute the time of <code>heavy.hpp</code> to either <code>h1.hpp</code> or <code>h2.hpp</code>, depending on which one got parsed first.</p> <p>This means that if we want to eliminate <code>heavy.hpp</code> from the include tree, we might need to tweak code &amp; generate the profile multiple times in order to locate all the headers responsible for bringing it in.</p>"},{"location":"technical_limitations.html#implementation-parsing-time","title":"Implementation parsing time","text":"<p>Since <code>-ftime-trace</code> only exposes parsing events for headers, we have no real way to deduce the parsing time of <code>.cpp</code> itself.</p> <p>In practice this is not a particularly important limitation since the overwhelming majority of parsing is going to be spent on includes.</p>"},{"location":"technical_limitations.html#generalizing-template-alias-prettification","title":"Generalizing template alias prettification","text":"<p>Debug info in C++ usually contains templates in their fully expanded form, for example, a seemingly short template like <code>std::string</code> when fully expanded will look more like <code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code>. In some cases this representation may also include additional implementation-specific subtypes and typedefs.</p> <p>For the standard library templates, <code>clang-build-profiler</code> contains an extensive number of simplification rules:</p> <ul> <li>Implementation-specific spacing and formatting is normalized</li> <li>Implementations-specific namespaces (like <code>std::__cxx11::</code>) are collapsed</li> <li>Known expansions (like <code>std::ratio&lt;1, 1000&gt;</code>, <code>std::chrono::duration&lt;long long, std::ratio&lt;1, 1000000&gt;&gt;</code>, <code>std::basic_ifstream&lt;char&gt;</code> and etc.) are collapsed to their shorter form (<code>std::milli</code>, <code>std::chrono::milliseconds</code>, <code>std::ifstream</code> and etc.)</li> <li>Known default arguments are collapsed (like <code>std::less&lt;void&gt;</code> which is equivalent to <code>std::less&lt;&gt;</code>)</li> <li>ABI suffixes are removed</li> </ul> <p>This greatly aids in terms of readability, however doing the same logic in general case is not really possible without analyzing the actual compiler AST, which is why 3rd party libraries and some standard implementations might still contain needlessly expanded templates.</p>"},{"location":"technical_limitations.html#granular-codegen-data","title":"Granular codegen data","text":"<p>Since <code>-ftime-trace</code> does not expose any events that could help us attribute code generation time to a particular class / function / file, this information is only available in terms of a general statistic.</p>"},{"location":"technical_limitations.html#preprocessing-time","title":"Preprocessing time","text":"<p>Since <code>-ftime-trace</code> does not separate preprocessing from the general parsing, any time spend in the preprocessor (which can be quite significant for some heavy recursive macros) will be attributed to the <code>Parsing</code> section.</p>"}]}